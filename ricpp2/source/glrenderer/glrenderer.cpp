// RICPP - RenderMan(R) Interface CPP Language Binding////     RenderMan(R) is a registered trademark of Pixar// The RenderMan(R) Interface Procedures and Protocol are://         Copyright 1988, 1989, 2000, 2005 Pixar//                 All rights Reservered//// Copyright (c) of RiCPP 2007, Andreas Pidde// Contact: andreas@pidde.de//// This library is free software; you can redistribute it and/or// modify it under the terms of the GNU General Public// License as published by the Free Software Foundation; either// version 2 of the License, or (at your option) any later version.//  // This library is distributed in the hope that it will be useful,// but WITHOUT ANY WARRANTY; without even the implied warranty of// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU// General Public License for more details.//// You should have received a copy of the GNU General Public// License along with this library; if not, write to the Free Software// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA/** @file glrenderer.cpp *  @author Andreas Pidde (andreas@pidde.de) *  @brief Implementation of a context to do some draft OpenGL rendering */#include "ricpp/glrenderer/glrenderer.h"#ifndef _RICPP_RICONTEXT_RIMACRO_H#include "ricpp/ricontext/rimacro.h"#endif // _RICPP_RICONTEXT_RIMACRO_H#if defined(WIN32)#include <GL/gl.h>#else#if defined(__APPLE__)#include <OpenGL/gl.h>#include <OpenGL/OpenGL.h>#else#include <GL/gl.h>#endif#endif#include <iostream>using namespace RiCPP;// -----------------------------------------------------------------------------const char *CGLRendererCreator::myName() { return GLRENDERERCREATOR_NAME; }const char *CGLRendererCreator::myType() { return CContextCreator::myType(); }unsigned long CGLRendererCreator::myMajorVersion() { return CContextCreator::myMajorVersion(); }unsigned long CGLRendererCreator::myMinorVersion() { return 1; }unsigned long CGLRendererCreator::myRevision() { return 1; }const char *CGLRenderer::myName() { return GLRENDERER_NAME; }const char *CGLRenderer::myType() { return IRiContext::myType(); }unsigned long CGLRenderer::myMajorVersion() { return IRiContext::myMajorVersion(); }unsigned long CGLRenderer::myMinorVersion() { return 1; }unsigned long CGLRenderer::myRevision() { return 1; }RtToken CGLRenderer::myRendererType() { return RI_DRAFT; }CGLRenderer::CGLRenderer() : m_validGL(false){}CGLRenderer::~CGLRenderer(){}void CGLRenderer::defaultDeclarations(){	CBaseRenderer::defaultDeclarations();}void CGLRenderer::initFrame(){#if defined(__APPLE__)	{		CGLContextObj o = CGLGetCurrentContext();		if ( o ) {			// std::cout << "# GL Context is available" << std::endl;			m_validGL = true;		} else {			// std::cout << "# GL Context is not available" << std::endl;			m_validGL = false;		}	}#endif	// If an OpenGL context is valid, take this one	// else open a GL window with the current display and frame settings	// sets m_validGL}void CGLRenderer::initHider(){	// Sets the hider type (hidden, painter, null)}void CGLRenderer::initViewing(){	// Inits the viewing matrices}void CGLRenderer::initLights(){	// Inits the global light sources or the default light source - the default lightsource will be removed, if a light source is defined}RtVoid CGLRenderer::doBegin(CRiBegin &obj, RtString name, const CParameterList &params){}RtVoid CGLRenderer::doEnd(CRiEnd &obj){	if ( !valid() )		return;	// if own window: Wait for window to get closed and destroy opengl context}RtVoid CGLRenderer::doWorldBegin(CRiWorldBegin &obj){	initFrame();	if ( !valid() )		return;	initHider();	initViewing();	initLights();}RtVoid CGLRenderer::doWorldEnd(CRiWorldEnd &obj){	if ( !valid() )		return;	// Render postponed surfaces	// Flush GL}RtVoid CGLRenderer::doGeneralPolygon(CRiGeneralPolygon &obj, RtInt nloops, RtInt nverts[], const CParameterList &params){	if ( !valid() )		return;		// Just a q&d test	const CTriangulatedPolygon *tp = obj.triangulate(triangulationStrategy());	if ( !tp )		return;	CParameter *par = params.get(RI_P);	if ( !par )		return;		const std::vector<RtFloat> &p = par->floats();	const std::vector<unsigned long> &triangles = tp->triangles();	std::vector<unsigned long>::const_iterator iter = triangles.begin();		// std::cout << "# Print Polygon" << std::endl;	RtFloat x, y, z;	while ( iter != triangles.end() ) {		glBegin(GL_TRIANGLES);		x = p[(*iter)*3];		y = p[(*iter)*3+1];		z = p[(*iter)*3+2];		glVertex3f(x, y, z);		// std::cout << "# " << x << " " << y << " " << z << std::endl;		++iter;			x = p[(*iter)*3];		y = p[(*iter)*3+1];		z = p[(*iter)*3+2];		glVertex3f(x, y, z);		// std::cout << "# " << x << " " << y << " " << z << std::endl;		++iter;		x = p[(*iter)*3];		y = p[(*iter)*3+1];		z = p[(*iter)*3+2];		glVertex3f(x, y, z);		// std::cout << "# " << x << " " << y << " " << z << std::endl;		++iter;		// std::cout << std::endl;		glEnd();	}		// Build surfaces (mind: motion, depth of field, LOD, opacity)	// Manage Surfaces:	//     shaders	//     if opaque: hide surface and remove surface	//     else if transparent: postpone surface (order by z)}