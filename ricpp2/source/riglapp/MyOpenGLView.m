#import "ricpp/riglapp/MyOpenGLView.h"#import "ricpp/ri/ri.h"#import <OpenGL/gl.h>void testPolyHole4(){	RtFloat p[] = {		// outer		0, 0, 0, //  1		0, 6, 0, //  2		6, 6, 0, //  3		6, 0, 0, //  4				//  5		//  6				// inner (hole)		1, 1, 0,  //  7		3, 1, 0,  //  8		3, 3, 0,  //  9		1, 3, 0,  // 10				//  11		//  12				// inner (hole)		3, 3, 0,  // 13		5, 3, 0,  // 14		5, 5, 0,  // 15		3, 5, 0,  // 16				0	};		RtInt nverts[] = {		4,		4,		4	};		RtInt i,j,n,nloops;		nloops = sizeof(nverts)/sizeof(nverts[0]);		for ( j = 0, n = 0; j < nloops; ++j ) {		for ( i = 0; i < nverts[j]; ++i ) {			p[n+i*3+0] = p[n+i*3+0] / 8.0 - 0.5;			p[n+i*3+1] = p[n+i*3+1] / 8.0 - 0.5;			p[n+i*3+2] = p[n+i*3+1] / 8.0 - 0.5;		}		n += nverts[j]*3;	}		RiGeneralPolygon(nloops, nverts, RI_P, &p, RI_NULL);}void testPolyHole3(){	RtFloat p[] = {		// outer		0, 0, 0, //  1		0, 6, 0, //  2		7, 6, 0, //  3		7, 0, 0, //  4				//  5		//  6				// inner (hole)		1, 1, 0,  //  7		3, 1, 0,  //  8		3, 3, 0,  //  9		1, 3, 0,  // 10				//  11		//  12				// inner (hole)		4, 3, 0,  // 13		6, 3, 0,  // 14		6, 5, 0,  // 15		4, 5, 0,  // 16						0	};		RtInt nverts[] = {		4,		4,		4	};		RtInt i,j,n,nloops;		nloops = sizeof(nverts)/sizeof(nverts[0]);		for ( j = 0, n = 0; j < nloops; ++j ) {		for ( i = 0; i < nverts[j]; ++i ) {			p[n+i*3+0] = p[n+i*3+0] / 8.0 - 0.5;			p[n+i*3+1] = p[n+i*3+1] / 8.0 - 0.5;			p[n+i*3+2] = p[n+i*3+1] / 8.0 - 0.5;		}		n += nverts[j]*3;	}		RiGeneralPolygon(nloops, nverts, RI_P, &p, RI_NULL);}void testPolyHole2(){	RtFloat p[] = {		// outer		0, 0, 0, //  1		0, 7, 0, //  2		7, 7, 0, //  3		7, 0, 0, //  4				//  5		//  6				// inner (hole)		1, 1, 0,  //  7		3, 1, 0,  //  8		3, 3, 0,  //  9		1, 3, 0,  // 10				//  11		//  12		// inner (hole)		4, 1, 0,  // 13		6, 1, 0,  // 14		6, 3, 0,  // 15		4, 3, 0,  // 16				//  17		//  18				// inner (hole)		4, 4, 0,  // 19		6, 4, 0,  // 20		6, 6, 0,  // 21		4, 6, 0,  // 22				//  23		//  24		// inner (hole)		1, 4, 0,  //  7		3, 4, 0,  //  8		3, 6, 0,  //  9		1, 6, 0,  // 10		0	};		RtInt nverts[] = {		4,		4,		4,		4,		4	};		RtInt i,j,n,nloops;		nloops = sizeof(nverts)/sizeof(nverts[0]);		for ( j = 0, n = 0; j < nloops; ++j ) {		for ( i = 0; i < nverts[j]; ++i ) {			p[n+i*3+0] = p[n+i*3+0] / 8.0 - 0.5;			p[n+i*3+1] = p[n+i*3+1] / 8.0 - 0.5;			p[n+i*3+2] = p[n+i*3+1] / 8.0 - 0.5;		}		n += nverts[j]*3;	}		RiGeneralPolygon(nloops, nverts, RI_P, &p, RI_NULL);}void testPolyHole(){	RtFloat p[] = {		// outer		1, 1, 0, // 0		1, 8, 0, // 1		4, 8, 0, // 2		5, 6, 0, // 3		6, 8, 0, // 4		7, 8, 0, // 5				// inner (hole)		2, 5,   0,  // 6		2, 6,   0,  // 7		3, 5.5, 0,  // 8				// inner (hole)		2, 3,   0,  //  9		2, 4,   0,  // 10		3, 3.5, 0,  // 11				0	};		RtInt nverts[] = {		6,		3,		3	};		RtInt i,j,n,nloops;		nloops = sizeof(nverts)/sizeof(nverts[0]);		for ( j = 0, n = 0; j < nloops; ++j ) {		for ( i = 0; i < nverts[j]; ++i ) {			p[n+i*3+0] = p[n+i*3+0] / 8.0 - 0.5;			p[n+i*3+1] = p[n+i*3+1] / 8.0 - 0.5;			p[n+i*3+2] = p[n+i*3+1] / 8.0 - 0.5;		}		n += nverts[j]*3;	}		RiGeneralPolygon(nloops, nverts, RI_P, &p, RI_NULL);}void testPoly(){	// O'Rourke's poly 1.1	RtFloat p[] = {		// outer		0,  0, 0, //  0		10,  7, 0, //  1		12,  3, 0, //  2		20,  8, 0, //  3		13, 17, 0, //  4		10, 12, 0, //  5		12, 14, 0, //  6		14,  9, 0, //  7		8, 10, 0, //  8		6, 14, 0, //  9		10, 15, 0, // 10		7, 18, 0, // 11		0, 16, 0, // 12		1, 13, 0, // 13		3, 15, 0, // 14		5,  8, 0, // 15		-2,  9, 0, // 16		5,  5, 0  // 17	};		RtInt nverts[] = {		18	};		RtInt i,j,n,nloops;		nloops = sizeof(nverts)/sizeof(nverts[0]);		for ( j = 0, n = 0; j < nloops; ++j ) {		for ( i = 0; i < nverts[0]; ++i ) {			p[n+i*3+0] = p[n+i*3+0] / 18.0 - 0.5;			p[n+i*3+1] = p[n+i*3+1] / 18.0 - 0.5;			p[n+i*3+2] = p[n+i*3+1] / 18.0;		}		n += nverts[j]*3;	}		RiGeneralPolygon(nloops, nverts, RI_P, &p, RI_NULL);}static void drawAnObject (){	// Opaque	glColor4f(0.0f, 0.35f, 0.0f, 1.0f);	glBegin(GL_TRIANGLES);	{		glVertex3f( 0.1, 0.5, -0.15);		glVertex3f( -0.1, -0.3, -0.15);		glVertex3f( 0.3, -0.3 , -0.15);	}	glEnd();	// Transparent from far to near	glColor4f(1.0f, 0.85f, 0.35f, 0.5f);	glBegin(GL_TRIANGLES);	{		glVertex3f(  0, 0.5, -0.1);		glVertex3f( -0.5, -0.3, -0.1);		glVertex3f( 0.5, -0.3 , -0.1);	}	glEnd();	glColor4f(0.0f, 0.0f, 0.35f, 0.5f);	glBegin(GL_TRIANGLES);	{		glVertex3f( 0.3, 0.5, -0.3);		glVertex3f( 0.1, -0.3, -0.3);		glVertex3f( 0.5, -0.3 , -0.3);	}	glEnd();}@implementation MyOpenGLView-(void) drawRect: (NSRect) bounds{	/* NSLog(@"drawRect"); */	glEnable(GL_DEPTH_TEST);	glDisable(GL_CULL_FACE);	glClearDepth(1.0);	glClearColor(1.0,1.0,1.0,0);	glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);		glDepthFunc(GL_LEQUAL);		glEnable(GL_ALPHA_TEST);	glAlphaFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);		glEnable(GL_BLEND);	glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);		glColor4f(0.0f, 0.35f, 0.0f, 1.0f);	RiWorldBegin();	// testPoly();	// testPolyHole();	// testPolyHole2();	testPolyHole3();	// testPolyHole4();	// drawAnObject();	RiWorldEnd();		glFlush();}@end